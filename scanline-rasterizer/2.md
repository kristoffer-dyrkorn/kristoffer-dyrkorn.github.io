<div style="text-align:right; color:#aaa">Kristoffer Dyrkorn, March 10, 2025</div>

# Living on the edge

(This article is part of a [series](./#sections). You can jump to the [previous section](1) or the [next section](3) if you would like to.)

The rasterizer is based on fundamental two operations: Scan converting edges and drawing horizontal lines.

Drawing horizontal lines is not too complicated, but the scan conversion has some more complexity to it. In this section we will take a closer look at what we can do to ensure correctness and good performance.

## Numerical issues

The current scan converter operates on floating point values. It calculates the edge slope as `dx/dy`, and increments the current `x` coordinate with this value as it traverses the edge along the `y` coordinate.

This has two downsides: Performance and precision. Divisions can be slow, and if possible, we would like to avoid them. Admittedly, slow divisions used to be more of an issue before, on older computers. However, precision is still a potential problem for us. Adding long sequences of floating-point numbers will lead to errors - as the numerical precision of the initial division, and then of each addition, is finite. The limited precision will lead to visual artifacts - gaps or overlaps between two triangles that share an edge. See [this section](triangle-rasterizer/7) in the previous article series for more details.

We will now change the scan converter to be exact. It will operate on integers only, eliminating the risk of numerical errors. How can we do that? Ie, how can we calculate the edge slope without performing a division? The trick here is to keep the slope value as a fraction, and to never perform the divide. We instead store the numerator and denominator, and apply normal rules for additions of fractions to get the output we need.

You may have already heard of an integer-based algorithm for line drawing (Bresenham's), and we could have used that here as well. However, some of the refinements we will do later in this series are much easier to implement when we choose the fraction-based approach.

## The solution

Let's see how the integer-based scan converter looks like. In this example, we assume the edge runs downwards and to the right, and that the major axis (the largest dimension) for the edge is along the `y` axis. This means we have to iterate along the `y` axis from start to end (top to bottom), and to find an `x` coordinate for each integer `y`.

We start off by calculating the `dx` and `dy` values for the edge - ie the difference in `x` and `y`. The edge slope can be expressed as `dx/dy`, but we choose to not calculate this value itself. We also read out the pixel coordinates of the start point of the edge.

```JavaScript
  scan(start, end, buffer) {
    const dx = end[0] - start[0];
    const dy = end[1] - start[1];

    let x = start[0];
    let y = start[1];
```

We now prepare our fraction by introducing a `numerator` variable. The denominator will here be the `dy` variable. We then add the slope (expressed as a fraction, and not a real-value number) to the `x` coordinate as we iterate over the `y` axis of the edge from top to bottom.

```JavaScript
    let numerator = 0;

    while (y <= end[1]) {
      numerator += dx;
      if (numerator > dy) {
          x++;
          numerator -= dy;
      }
      buffer[y] = x;
      y++;
    }
```

For each iteration, we add `dx` to the numerator, and check whether the fraction overflows - ie, whether the numerator becomes larger than the denominator. If so, we move one pixel coordinate to the right by increasing `x`, and then we subtract the denominator value from the numerator. This way we keep the fraction a true fraction (having a value of less than 1) - and it expresses the horizontal position inside the current pixel.

That is all there is to it! Handling the remaning cases, where an edge run downwards to the left, or when the major axis (the largest dimension) is along the `x` axis, is not too hard. See the [source code](2/triangle.js) for details - the changes are mostly swapping `dx` with `dy` and changing signs.

# The top left rule

We need to adjust the code where we draw the horizontal lines. If you have read the previous article series on rasterizing, you may remember the "top left rule". (See [section 4](triangle-rasterizer/4) if you want.) Right now the pixels that lie on edges that are shared between two triangles will be drawn twice. We would like to avoid that, as it both is unnecessary work and creates visual artifacts.

A quick way to avoid drawing pixels twice is to skip drawing the top horizontal line of a triangle, and to also skip the leftmost pixel of each horizontal line. This is not too hard to implement.

The change looks like this:

```JavaScript
    // we start at ymin+1 due to "top left" rasterization rule
    let y = ymin + 1;
    while (y <= ymax) {
      // we start at xmin+1 due to "top left" rasterization rule
      let x = this.startBuffer[y] + 1;
      let endx = this.endBuffer[y];
      let i = imageDataOffset + (x << 2);

      while (x <= endx) {
        (...)
      }
      y++;

      // point to x=0 on the next line
      imageDataOffset += this.imageData.width << 2;
    }
```

And with that, we have our first exact scanline rasterizer up and running! In the [next section](3) we will look at how we can draw the horizontal lines a bit more efficiently. In the mean time, have a look at the [demo app for this section](2/)! Please note that our rasterizer only operates on integer pixel coordinates. This means that the animation is not smooth. We will improve on that in a later section.
