<div style="text-align:right; color:#aaa">Kristoffer Dyrkorn, March 10, 2025</div>

# Epilogue

(This article is the last part of a [series](./#sections). You can jump to the [previous section](9) if you would like to.)

In a serial runtime environment, it is likely faster than Piñeda's algorithm due to the simpler inner loop (no if test in the innermost loop). In principle, scanline conversion replaces sampling with more direct computation. BUT it also relies on reading x coordinates from tables. Memory accesses are _much_ slower than register accesses, so a possible improvement here would be to try to inline the edge computations, ie to run the algorithm on registers only. (We still need to write color values to our screen buffer, so we will not get rid of memory writes alltogether.)

Which of the two methods is _best_?

Well - how advanced rendering do you need? Ie: How many properties do you need to interpolate over? Color, UV, vertex normal, etc? Scanline conversion code becomes complicated once you interpolate over more than 2-3 properties. This is much more easily handled by the Piñeda algorithm.

It also depends on your runtime environment, ie whether it is parallel or serial, and whether performance or graphics realism has the highest priority.
