<div style="text-align:right; color:#aaa">Kristoffer Dyrkorn, March 10, 2025</div>

# Use the math, Luke

(This article is part of a [series](./#sections). You can jump to the [previous section](4) or the [next section](6) if you would like to.)

In the previous section we calculated a new initial value for the numerator. This was the code we added:

```JavaScript
    // get the fractional x coordinate where the edge intersects the horizontal line through the pixel center
    const x_intersect = start_x_fractional - Math.round((start_y_fractional - FixedPointVector.HALF) * dx_dy);

    // calculate the horizontal offset from the ideal starting point (the pixel center)
    const x_offset = x_intersect - FixedPointVector.HALF;

    // convert the offset into a numerator value, by multiplying by dy and rounding off
    let numerator = (dy * x_offset + FixedPointVector.HALF) >> FixedPointVector.SHIFT;
```

It turns out the calculations can be simplified quite a bit. If we remove the rounding when calculating `x_intersect`, and keep in mind that `dx_dy` actually is `dx / dy`, the expressions can be merged into one and rewritten as:

```JavaScript
    let numerator = (dy * (start_x_fractional - FixedPointVector.HALF) -
                     dx * (start_y_fractional - FixedPointVector.HALF)) >> FixedPointVector.SHIFT;
```

This means that we only need to do two multiplications and three subtractions to add subpixel precision to the scan conversion process. Not bad! The improvement in visual quality certainly is certainly worth the extra calculations.

Also note that the last expression is more exact than the first - as we neither do any divisions, nor any rounding, any more.

Have a look at the [final version of the demo app](5/). In the [next section](6) we will round off this article series with some thoughts and observations on the two rasterizing methods.
