<div style="text-align:right; color:#aaa">Kristoffer Dyrkorn, March 10, 2025</div>

# Faster horizontal lines

(This article is part of a [series](./#sections). You can jump to the [previous section](2) or the [next section](4) if you would like to.)

Our rasterizer is inherently serial. There are no functions that run in parallel. Given our runtime environment, JavaScript in the browser, we have no obvious way to make the code do more per time unit. (Web workers have far too much overhead to be useful here, we requre very little overhead.)

Still, we want to make our more effective. We can make use of a little trick: although we cannot make our code run in parallel, we can make the data processing happen in parallel. Or, at least, we can make the code process more data per unit of time.

This is often referred to as SIMD - single instruction, multiple data. The idea is that in a tight loop that does simple data copying or writing, it is often more effective to work on larger data chunks in each iteration.

In the current code to draw horizontal lines, we write pixel values to our screen buffer one byte at a time. That means we need to send 4 bytes to the screen buffer to update one pixel on the screen. However, writing 4 bytes (one pixel) at a time is just as fast as writing 1 byte. This means we can make the loop run faster if we set up the code to update one pixel - 4 bytes - at a time.

## The implementation

We do this by wrapping the raw image data buffer (an array buffer created by the Canvas API) in a typed array (here: a Uint32Array). This creates a view into the raw image buffer for us - that enables us to write 32 bits (4 bytes, ie a full pixel) at a time.

The code looks like this:

```JavaScript
  const arrayBuffer = imageData.data.buffer;
  screenBuffer = new Uint32Array(arrayBuffer);
```

When we want to write pixels on screen, we first make the 4 byte values into a single 32-bit integer. This only needs to be done once per triangle.

```JavaScript
    // bake the pixel color as a int32 RGBA value (little-endian)
    let finalColor = color[0];
    finalColor |= color[1] << 8;
    finalColor |= color[2] << 16;
    finalColor |= 255 << 24;
```

Then we can let the innermost pixel-drawing loop, where performance really matters, do just one write per iteration:

```JavaScript
    while (x <= endx) {
      this.buffer[screenOffset + x] = finalColor;
      x++;
    }
```

And with that, we now draw our horizontal lines more effectively.

In the next section, we will take a deep dive into scan conversion again. We will (finally) start improving the visual quality of the animation - we will add support for subpixel precision so the triangles rotate smoothly!

If you want, you can have a look at the [demo app for this section](3/) - or, you can just jump directly to the [next section](4).
