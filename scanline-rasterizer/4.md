<div style="text-align:right; color:#aaa">Kristoffer Dyrkorn, March 10, 2025</div>

# How to be smooth

(This article is part of a [series](./#sections). You can jump to the [previous section](3) or the [next section](5) if you would like to.)

To get smoother animation we will now introduce subpixel precision to our rasterizer.

This will happen in multiple steps. We will first switch to using real-valued coordinates as the input to the rasterizer. The vertex coordinates we operate on when drawing triangles will no longer be integers.

For more info about what that change means, see [previous article on continuous coordinates](triangle-rasterizer/6).

As in the previous article series we will use the fixed point representation to represent real values and still avoid numerical issues. See [the section](triangle-rasterizer/7#the-solution-fixed-point-numbers) if you are curious.

## What does this mean in practice?

The vertex coordinates will now have higher precision. Edge endpoints can therefore be located not just in the center of pixels, but anywhere inside a pixel (limited by the precision of the fixed point representation).

We will now make use of this information we scan convert edges. So, when traversing an edge in the `y` direction, we use fixed point values when we calculate whether to stay on the `x` coordinate, or to step one pixel to the side. The fraction we use for this will now use fixed point values, both in the numerator and the denominator.

The horizontal line drawing itself will not change. Both the `x` and `y` coordinates need to remain integers - as pixel adresses are integers after all. So, although we use fixed point values in the calculations, the horizontal line drawer operats on values that are truncated to integers.

The edge slope value also does not change, it is still `dx` over `dy`, but both values are now fixed point values.

As we traverse the edge downwards, we calculate an `x` coordinate per horizontal `y` line. We need to determine for which `y` the calculations should apply. We pick the most representative location, which is the pixel center in the vertical direction, at `y` coordinate (integer) + 0.5.

The changes so far are mainly related to data types and conventions. The actual change in logic is related to how we initialize the variable that guides the scan conversion process: The numerator of our fraction.

The numerator decides when to step one pixel to the side. It encodes the horizontal position of the edge inside the current pixel, ie the fractional `x` coordinate. In our existing code, the numerator is initially set to zero, to reflect that our starting `x` coordinate is on the pixel center.

We need to calculate a new initial value for the numerator. The new value needs to reflect the `x` coordinate of the starting point of the edge. Our horizontal lines work on `y` values of `integer value` + 0.5, so we will extend the edge to this `y` coordinate, and calculate the horizontal distance to the pixel center there. This is what we will use as the initial value of the numerator.

Let's have a closer look at the geometry involved in this operation. If we correctly set up the initial value for the numerator, we have done all that is needed to support subpixel precision in the scan conversion process. The rest of the code stays the same.

Here is an illustration of a case where `y` is the major axis, and the edge goes down to the right - meaning that both `dx` and `dy` are positive. As before, the other cases can be supported via symmetry - ie by swapping `dx` with `dy` and changing signs in a few locations.

<p align="center">
<img src="images/4-numerator.png" width="75%">
</p>

The diagram is a bit complex, so let's look at it step by step.

The diagram shows a pixel that surrounds the starting point (the top end) of an edge we want to scan convert. The end point of the edge is located further down and to the right.

Now, look at the diagram, and start in the top left corner of the pixel. Follow the arrow to the right. This is the fractional `x` coordinate of the starting point of the edge. Follow the arrow downwards. This is the fractional `y` coordinate of the start point of the edge. (The edge continues downwards and to the right.) We now extend the edge upwards and to the left, so it intersects a horizontal line going through the center of the pixel. The vertical distance we have moved, from the start point and to the pixel center, is `fractional_y - 0.5`. The horizontal distance we have moved is `(fractional_y - 0.5) * dx / dy`. The `y` coordinate of our current location is 0.5, and the `x` coordinate is `fractional_x - 0.5 - (fractional_y - 0.5) * dx / dy`.

The `x` coordinate represents the horizontal distance from the pixel center and to the starting point of the edge - when the edge has been extended to the vertical pixel center.

We will now need to convert this value into the same unit or measurement as the numerator uses. The numerator value does not encode horizontal distances directly, the entire fraction (numerator divided by denominator) that does that. So this means that the numerator encodes the distance pre-multiplied by the denominator. To provide a correct initial numerator value we thus need to multiply the horizontal distance by the denominator, `dy`.

The resulting code is:

```JavaScript
    // get the fractional x coordinate where the edge intersects the horizontal line through the pixel center
    const x_intersect = start_x_fractional - Math.round((start_y_fractional - FixedPointVector.HALF) * dx_dy);

    // calculate the horizontal offset from the ideal starting point (the pixel center)
    const x_offset = x_intersect - FixedPointVector.HALF;

    // convert the offset into a numerator value, by multiplying by dy and rounding off
    let numerator = (dy * x_offset + FixedPointVector.HALF) >> FixedPointVector.SHIFT;
```

The code where we traverse the edge downwards now becomes:

```JavaScript
    // get the x coordinate of the first pixel
    let x = start[0];

    // truncate the fixed point start and end y coordinates since we operate on integer y coordinates
    let y = start[1] >> FixedPointVector.SHIFT;
    let end_y = end[1] >> FixedPointVector.SHIFT;

    while (y < end_y) {
      numerator += dx;
      if (numerator > dy) {
        x += signdx;
        numerator -= dy;
      }
      buffer[y] = x;
      y++;
    }
```

In other words: The inner loop does not change! The change needed to enable subpixel support is restricted to the setup code outside the loop - where we calculate inital value for the numerator. The extra operations are only needed once per edge conversion, which means that subpixel support is fast!

Have a look at the [demo app for this section](4/) - and notice how smooth the animation now runs! There is no noticeable performance hit either. However, there is an old saying that a software rasterizer will never be too fast, so in the [next section](5) we will optimize the setup code we just added.
