<div style="text-align:right; color:#aaa">Kristoffer Dyrkorn, May 4, 2024</div>

# Cubes, golfing and dual identities - part 2

This is part 2 of the blog series on cubes, golf and double identities. Now we will look at rewriting the code so that it takes up less space. If anyone is wondering what this has to do with golf: Solving a given problem with the least amount of code is sometimes called code-golfing.

<p align="center">
<img src="images/blue_cube_2.png" width="90%">
</p>

In the previous blog post, we created some code that we will now shorten. But first of all: Why is it interesting to shorten source code? In common web solutions, compression of code and static resources is important to achieve good client-side performance. Here in this blog post, performance is not the point. The point is to look at how a given programming language gives us opportunities to express things.

If we deal with some code, and cut down on statements and structures as much as possible, what are we left with? What are the differences between the actual basis of a language, that which is necessary for the code to run and do what it is supposed to, and normal code, which often has lots of conventions added on top? When looking at program code, what has been added of text just to increase readability? What does a language look like if we take this away?

Compression is also an exercise in assessing what it is that must be exact in a program. Can you save space by being imprecise? Can an approximate result be good enough? As we are working here with JavaScript, we cannot avoid the coercion type phenomenon either. What opportunities do you get if you (mis-)use this? JavaScript gives us many possibilities and it can make it interesting to explore the language.

Some may wonder what the use of such explorations is. I think they are excellent exercises in thinking creatively while programming. This is because you write code with a completely different starting point for what is "optimal" than what you otherwise do. In addition, you gain a lot of knowledge about the language you work in, about hacks and about strengths and weaknesses, and about various traps you can fall into. Knowing the peculiarities of the language you work in is extremely valuable when you have to focus on write correct code.

But first two warnings: This will get pretty nerdy. And: The tricks here will lie a long way from what can be called good programming practice. If you want to learn more about such tricks in JavaScript, please have a look at the links at the bottom of this blog post.

Okay, let's begin. In part 1, we therefore created code that displayed a spinning cube on the screen. The code from there must now be shortened. As previously mentioned, all tricks are allowed, the only thing that applies is to save space, that things work and that the cube looks roughly the same as before.

We first shorten the names of the tables, and drop var. In other words, we blow in strict mode, but all tricks are allowed:

```
p = [-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1];
r = [];
f = [0, 1, 2, 3, 0, 3, 7, 4, 0, 4, 5, 1, 6, 5, 4, 7, 6, 2, 1, 5, 6, 7, 3, 2];
```

Then we consider the function that rotates the coordinates around the z and y axes. We know that we must rotate 8 points each with their own x-, y- and z-coordinates, and then we also know that i must go from 0 to 24. By reversing the order of the lines that calculate y-rotation need we no longer use a temporary variable. The function then becomes like this:

```
function rotate(y, z) {
  for (i=0; i<24; i+=3) {
    r[i] = p[i] * Math.cos(z) - p[i+1] * Math.sin(z);
    r[i+1] = p[i] * Math.sin(z) + p[i+1] * Math.cos(z);
    r[i+2] = p[i+2] * Math.cos(y) - r[i] * Math.sin(y);
    r[i] = p[i+2] * Math.sin(y) + r[i] * Math.cos(y);
  }
}
```

In the same way, we update the function to calculate perspective:

```
function project(s, d) {
  for (i=0; i<24; i+=3) {
    r[i] = s * r[i] / (d - r[i+2]) + canvas.width/2;
    r[i+1] = -s * r[i+1] / (d - r[i+2]) + canvas.height/2;
  }
}
```

...and the function that draws the cube:

```
function draw() {
  for (i=0; i<24; i+=4) {
    ctx.beginPath();
    ctx.moveTo(r[3*f[i]], r[3*f[i]+1]);
    s = r[3*f[i]+2];

    for (j=1; j<4; j++) {
      ctx.lineTo(r[3*f[i+j]], r[3*f[i+j]+1]);
      s += r[3*f[i+j]+2];
    }

    s = s / 4;

    ctx.closePath();
    ctx.fillStyle = colors[i/4];
    if (s > 0.15) {
      ctx.fill();
    }
  }
}
```

We have now reduced the code a bit, it is 1581 bytes. It is compact, and not very readable anymore. Can it be shrunk more? Yes!

We start with a real trick. Hold on tight! Let's look at `rotate()`` one more time. The function looked like this:

```
function rotate(y, z) {
  for (i=0; i<24; i+=3) {
    r[i] = p[i] * Math.cos(z) - p[i+1] * Math.sin(z);
    r[i+1] = p[i] * Math.sin(z) + p[i+1] * Math.cos(z);
    r[i+2] = p[i+2] * Math.cos(y) - r[i] * Math.sin(y);
    r[i] = p[i+2] * Math.sin(y) + r[i] * Math.cos(y);
  }
}
```

There are many calls to `Math.sin()` and `Math.cos()` here. They can be simplified a bit. If you are very into that sort of thing, you might remember that `sin(x) = cos(x - PI/2)` if the angles are given in radians. At the same time, `sin(x)` is periodic, i.e. `sin(x)` is equal to `sin(x + n*2*PI)`. Thus, `sin(x) = cos(x - PI/2) = cos(x - PI/2 + n*2*PI)`, or put another way: `sin(x)` can be expressed as `cos(x + "something")`. Is there a value for `"something"` that takes up little space? Let's start with `n=1` and see what happens:

```
-PI/2 + 1*2*PI = 4,712
-PI/2 + 2*2*PI = 10,995
```

Yes, the value 10.995 can fit! It is very close to 11, so the error is small if we just say that `sin(x)` is the same as `cos(x+11)`. If we introduce an alias for `Math.cos()`, we get the full effect of this. Here is the code when we have replaced all the calls to `Math.sin()`:

```
m = Math.cos;

function rotate(y, z) {
  for (i=0; i<24; i+=3) {
    r[i] = p[i] * m(z) - p[i+1] * m(z+11);
    r[i+1] = p[i] * m(z+11) + p[i+1] * m(z);
    r[i+2] = p[i+2] * m(y) - r[i] * m(y+11);
    r[i] = p[i+2] * m(y+11) + r[i] * m(y);
  }
}
```

The function that calculates perspective looked like this:

```
function project(s, d) {
  for (i=0; i<24; i+=3) {
    r[i] = s * r[i] / (d - r[i+2]) + canvas.width/2;
    r[i+1] = -s * r[i+1] / (d - r[i+2]) + canvas.height/2;
  }
}
```

Here, the for loop has the same structure as in `rotate(...)`, so we can put the content in `project(...)` in there. At the same time, we change the method name and signature of the combined function to `transform(y, z, s, d)`:

```
function transform(y, z, s, d) {
  for (i=0; i<24; i+=3) {
    r[i] = p[i] * m(z) - p[i+1] * m(z+11);
    r[i+1] = p[i] * m(z+11) + p[i+1] * m(z);
    r[i+2] = p[i+2] * m(y) - r[i] * m(y+11);
    r[i] = p[i+2] * m(y+11) + r[i] * m(y);
    r[i] = s * r[i] / (d - r[i+2]) + canvas.width/2;
    r[i+1] = -s * r[i+1] / (d - r[i+2]) + canvas.height/2;
  }
}
```

In the drawing function, we use the average of the z-coordinates to determine whether a surface is visible or not. To save some space, we might as well use the sum of the z-coordinates. This will work as long as we also adjust the value we are comparing to (in this case: multiply it by 4). New code:

```
function draw() {
  for (i=0; i<24; i+=4) {
    ctx.beginPath();
    ctx.moveTo(r[3*f[i]], r[3*f[i]+1]);
    s = r[3*f[i]+2];

    for (j=1; j<4; j++) {
      ctx.lineTo(r[3*f[i+j]], r[3*f[i+j]+1]);
      s += r[3*f[i+j]+2];
    }

    ctx.closePath();
    ctx.fillStyle = colors[i/4];
    if (s > 0.6) {
      ctx.fill();
    }
  }
}
```

We can actually use the sum of the z-values for one more thing: To control the color of the surface. We can move away from having fixed colors on the surfaces to achieve a kind of lighting effect. The sum of the z values for a visible surface will lie between 0.6 and 4, and we can scale up the sum so that the value can be used as an RGB value when a color is to be specified. We red-value and green-value to 0, and let the sum value indicate blue-value. (The upscaling is done so that the sum value is a maximum of 255.) Since the colors of the surfaces are now calculated for each drawing, we can simultaneously remove the array that previously held the definitions of the colors — and thus save space.

The new drawing function looks like this:

```
function draw() {
  for (i=0; i<24; i+=4) {
    ctx.beginPath();
    ctx.moveTo(p[3*f[i]], p[3*f[i]+1]);
    s = p[3*f[i]+2];
    for (j=1; j<4; j++) {
      ctx.lineTo(p[3*f[i+j]], p[3*f[i+j]+1]);
      s += p[3*f[i+j]+2];
    }

    ctx.closePath();
    ctx.fillStyle = "rgb(0,0," + Math.trunc(127+s*32) + ")"
    if (s > 0.6) {
      ctx.fill();
    }
  }
}
```

The code is now 1443 bytes and is starting to become unreadable. The cube is still fine-fine:

<p align="center">
<img src="images/blue_cube_3.png" width="90%">
</p>

It is time to take more drastic action. We put all the code into animate(), put the constants directly into the perspective calculation, and use a common variable to hold the rotation around both the z and y axes. We then slightly change the way the cube rotates (it will now rotate equally fast around both axes), but we leave it as is. We put the values for m(x) and m(x+11) into variables and reuse these in both the z and y rotations.

```
function animate() {
  requestAnimationFrame(animate);

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  for (i=0; i<24; i+=3) {
    u = m(v+11);
    o = m(v);
    r[i] = p[i] * o - p[i+1] * u;
    r[i+1] = p[i] * u + p[i+1] * o;
    r[i+2] = p[i+2] * o - r[i] * u;
    r[i] = p[i+2] * u + r[i] * o;
    r[i] = 350 * r[i] / (5 - r[i+2]) + canvas.width/2;
    r[i+1] = -350 * r[i+1] / (5 - r[i+2]) + canvas.height/2;
  }

  for (i=0; i<24; i+=4) {
    ctx.beginPath();
    ctx.moveTo(r[3*f[i]], r[3*f[i]+1]);
    s = r[3*f[i]+2];

    for (j=1; j<4; j++) {
      ctx.lineTo(r[3*f[i+j]], r[3*f[i+j]+1]);
      s += r[3*f[i+j]+2];
    }
    ctx.closePath();
    ctx.fillStyle = "rgb(0,0," + Math.trunc(127+s*32) + ")"
    if (s > 0.6) {
      ctx.fill();
    }
  }

  v += .018;
}
```

We then remove all markup that _must_ not be included. There is actually quite a lot that is not needed. We also remove the semicolon and some whitespace — but also leave some whitespace to make it easier to work further with shortening the code. We also shorten the names of a couple more variables.

The code is now down to 847 bytes.

Now it's time to try to do something with the `for` loops. Can we increase `i` inside the loop blocks themselves and thus save some space? After some changes, `animate(...)` looks like this:

```
function animate() {
  requestAnimationFrame(animate)
  a.clearRect(0,0,c.width,c.height)
  for(i=0;i<24;i++) {
    u=m(v+11)
    o=m(v)
    r[i]=p[i]*o-p[i+1]*u
    r[i+1]=p[i]*u+p[i+1]*o
    r[i+2]=p[i+2]*o-r[i]*u
    r[i]=p[i+2]*u+r[i]*o
    r[i]=350*r[i]/(5-r[++i+1])+c.width/2
    r[i]=350*r[i]/(5-r[++i])+c.height/2
  }
  for(i=0;i<24;i++) {
    a.beginPath()
    a.moveTo(r[3*f[i]],r[3*f[i]+1])
    s=r[3*f[i]+2]
    for(j=3;j--;) {
      s+=r[3*f[++i]+2]
      a.lineTo(r[3*f[i]],r[3*f[i]+1])
    }
    a.closePath()
    a.fillStyle="rgb(0,0,"+(127+s*32|0)+")"
    .6<s&&a.fill()
  }
  v+=.02
}
```

Here we have changed two of the for loops by using `++i` and `i++` inside the blocks. Additionally, we've replaced `Math.trunc()` with `|0` (yes, it actually gives the same result), and the negative scaling factor has been removed. The cube will thus be drawn upside down now, but there will be no visible differences from before. We adopt short circuit evaluation and replace the `if` statement with an `&&`, and save one more byte by slightly increasing the rotation speed.

The code is now 810 bytes.

There is even more that can be done! We can slightly change how the canvas element gets its size — instead of setting the width via JavaScript, we can use CSS to scale up the element, and we then no longer need to read out window.innerWidth and window.innerHeight:

```
<canvas id=c style=width:99%><script>
v=0
m=Math.cos
a=c.getContext("2d")
(...)
```

By using CSS in this way, the drawing surface will thus be scaled up. This means that each individual pixel in the canvas becomes larger, i.e. the resolution in the canvas becomes worse. It may well be debated whether this change is actually acceptable — but we choose to go ahead with this result now. The scaling factor for the size of the cube needs to be adjusted down a bit in order for it to remain the right size on the screen. We also take care of what the width of the canvas will be, and reuse it further down in the code. Since most people have their browser window open in a height-to-width ratio of approximately 1:1, we can also use the width as a starting point when specifying a height.

The cube now looks like this:

<p align="center">
<img src="images/blue_cube_4.png" width="90%">
</p>

The changes in the code are shown here:

```
w=c.width

function animate() {
  requestAnimationFrame(animate)
  a.clearRect(0,0,w,w)
  for(i=0;i<24;i++) {
    u=m(v+11)
    o=m(v)
    r[i]=p[i]*o-p[i+1]*u
    r[i+1]=p[i]*u+p[i+1]*o
    r[i+2]=p[i+2]*o-r[i]*u
    r[i]=p[i+2]*u+r[i]*o
    r[i]=99*r[i]/(5-r[++i+1])+w/2
    r[i]=99*r[i]/(5-r[++i])+w/3
  }
  (...)
```

At this stage, it is the definitions of the coordinates and surfaces that take place. We can shorten the `f`-array by wrapping the numbers into a string and then using `String.split(“”)` to turn it into an array:

```
f="012303740451654762156732".split("")
```

Thus, we are at 741 bytes.

The second array, the p-array, we will wait a bit for. There are still more things that can be done here: Now it's time to send the input in `animate()` (ie everything except the `requestAnimationFrame()` call itself) to [Google's Closure compiler](https://closure-compiler.appspot.com/). What can it do for us if we turn on "Advanced optimizations", I wonder? The code returned is:

```
a.clearRect(0,0,w,w);for(i=0;24>i;i++)u=m(v+11),o=m(v),r[i]=p[i]*o-p[i+1]*u,r[i+1]=p[i]*u+p[i+1]*o,r[i+2]=p[i+2]*o-r[i]*u,r[i]=p[i+2]*u+r[i]*o,r[i]=99*r[i]/(5-r[++i+1])+w/2,r[i]=99*r[i]/(5-r[++i])+w/3;for(i=0;24>i;i++){a.beginPath();a.moveTo(r[3*f[i]],r[3*f[i]+1]);s=r[3*f[i]+2];for(j=3;j--;)s+=r[3*f[++i]+2],a.lineTo(r[3*f[i]],r[3*f[i]+1]);a.closePath();a.fillStyle="rgb(0,0,"+(127+32*s|0)+")";.6<s&&a.fill()}v+=.02;
```

Now we change the animation loop from using `requestAnimationFrame()` to using `setInterval(...)`. There is a variant of `setInterval(...)` that can take in two parameters: The code itself (as a string), and the time interval between each execution (as a number). We set the interval to 9 ms and turn down the rotation speed a little. We therefore change from:

```
function animate() {
  requestAnimationFrame(animate)

  <kode>
}
animate()
```

...to:

```
setInterval('<code>', 9)
```

This will go a little beyond the animation, it will now be more choppy than before since the drawing is not done as often as before. But we choose to accept it here.

The entire application then looks like this:

```
<canvas id=c style=width:99%><script>
v=0
a=c.getContext("2d")
w=c.width
m=Math.cos
p=[-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1]
f="012303740451654762156732".split("")
r=[]
setInterval('a.clearRect(0,0,w,w);for(i=0;24>i;i++)u=m(v+11),o=m(v),r[i]=p[i]*o-p[i+1]*u,r[i+1]=p[i]*u+p[i+1]*o,r[i+2]=p[i+2]*o-r[i]*u,r[i]=p[i+2]*u+r[i]*o,r[i]=99*r[i]/(5-r[++i+1])+w/2,r[i]=99*r[i]/(5-r[++i])+w/3;for(i=0;24>i;i++){a.beginPath();a.moveTo(r[3*f[i]],r[3*f[i]+1]);s=r[3*f[i]+2];for(j=3;j--;)s+=r[3*f[++i]+2],a.lineTo(r[3*f[i]],r[3*f[i]+1]);a.closePath();a.fillStyle="rgb(0,0,"+(127+32*s|0)+")";.6<s&&a.fill()}v+=.01;',9)</script>
```

We then remove the remaining line breaks, and finally get:

```
<canvas id=c style=width:99%><script>v=0;a=c.getContext("2d");w=c.width;m=Math.cos;p=[-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1];f="012303740451654762156732".split("");r=[];setInterval('a.clearRect(0,0,w,w);for(i=0;24>i;i++)u=m(v+11),o=m(v),r[i]=p[i]*o-p[i+1]*u,r[i+1]=p[i]*u+p[i+1]*o,r[i+2]=p[i+2]*o-r[i]*u,r[i]=p[i+2]*u+r[i]*o,r[i]=99*r[i]/(5-r[++i+1])+w/2,r[i]=99*r[i]/(5-r[++i])+w/3;for(i=0;24>i;i++){a.beginPath();a.moveTo(r[3*f[i]],r[3*f[i]+1]);s=r[3*f[i]+2];for(j=3;j--;)s+=r[3*f[++i]+2],a.lineTo(r[3*f[i]],r[3*f[i]+1]);a.closePath();a.fillStyle="rgb(0,0,"+(127+32*s|0)+")";.6<s&&a.fill()}v+=.01',9)</script>
```

The code is now 633 bytes. Phew. There is starting to be little that can be done with the source code itself. There are probably a few more things that can be done, but we've already geeked out quite a bit already. Nevertheless: There is actually one more compression trick that can be used. This is done in the browser and we will look at that in more detail in part 3 of this blog post.

But first: [Here](https://github.com/jed/140bytes/wiki/Byte-saving-techniques) and [here](https://slides.com/pdesch/js-demoscene-techniques) you will find nice tricks to minimize code. And the website of Mathieu Henri, aka [p01](http://www.p01.org/), is a must.
