<div style="text-align:right; color:#aaa">Kristoffer Dyrkorn, May 4, 2024</div>

# Cubes, golfing and dual identities - part 3

So far in this article series, we have created a small web app and refactored the source code to minimize the size. Here, in part 3, we will compress the code even more by playing tricks with the browser.

When web servers send data to browsers, the content is often compressed using a compression algorithm (for example, Deflate). This reduces the bandwidth and download latency. It is the web server's responsibility to do the compression, and the browser is responsible for decompressing the data so it can process it as normal. The Deflate algorithm is widely used and supported by all browsers out there. Depending on how the input looks like it can reduce normal text (or HTML, CSS or JavaScript) to about one third of the original size.

It would be interesting to try to run our code from part 2 through a compression algorithm and see what we get. The question is: How? We don't want to rely on a web server - the source code should stay completely self-contained. So we have to come up with something else.

Fortunately, someone has already come up with something else! [Cody Brocious](https://github.com/daeken/Benjen/blob/master/daeken.com/entries/superpacking-js-demos.md), aka Daeken, has found a way to further compress the code.

Let's take a closer look at the various data formats supported by browsers. Image files are one of them. And, some image formats (including PNG) use lossless compression schemes, including the Deflate algorithm. When decoding an image, the browser is responsible for decompressing the data - and this happens completely transparently for us. But then the question becomes: Can we somehow package our code in a PNG? Is that even possible? Will it work?

Yes, it works! Although code is text, code is also just byte values - just like the RGB values in an image. So we can encode our source code as bytes (by taking the ASCII value of each character), and then send the byte array to a PNG encoder. The output is an image that does not contain anything visually pleasing, but it does contain a Deflate-compressed version of our source code.

The next question becomes: How can we decompress the image, convert the bytes into text (source code), and then run the app? This where the notion of dual identities comes in. The PNG format supports so-called "custom chunks", which are metadata blocks inside a PNG that you can fill with whatever you want - including text. This means, we can fill a block with HTML and JavaScript if we want to.

If we rename a PNG, so it gets the file extension `.html`, and try to open it in a browser, the browser will assume the data is an HTML file. The browser will not understand the PNG data, but, as the standard says, it will ignore this and keep on reading. Then, when the browser sees our custom PNG chunk, it will recognize it as HTML and JavaScript, and read, interpret and run the code. So, the trick is to put a small JavaScript decoder for PNG data in the custom chunk. The decoder will read the byte values in the PNG, translate these data to ASCII text, and then run the output - ie the source code of our app.

To sum up, the procedure is:

- Start with the source code for the web app
- Convert the source code (ie the text) into a byte array and create a PNG out of it
- Create an byte-to-source code converter and app runner in JavaScript, and put it in the PNG in a custom chunk
- Rename the resulting PNG so it has the file extension `.html`

There are [ready-made generator scripts](https://gist.github.com/gasman/2560551) out there that can to this for us.

When the browser processes the file, this happens:

- The browser thinks the file contains HTML, but initially sees binary data, so the data is ignored and it keeps reading
- The browser reaches the decoder, recognizes it as valid code, parses and runs it
- The decoder points back to the image data at the beginning of the file, and the browser reads it in again and decompresses it for us
- The decoder converts each color value (each byte) in the image to a character, treats the resulting text string as source code, and executes it

Thus we have compressed the source code using Deflate compression without introducing a server or code to do explicit decompression. To achieve this, we rely on built-in browser features to handle image formats, and we use a file with dual identities: The app is both a PNG file and an HTML page containing JavaScript.

Let's see how this looks like in practice. We start with the decoder. It needs to be as compact as possible - and do as little as possible - since it will be stored uncompressed in the custom chunk inside the PNG. The decoder needs a canvas to get access to the pixel values, so we need add markup for that in the decoder. However, we can reuse the element in the application itself. Let's start with an existing decoder that is quite compact, and then set the width to 99% as we have done before, it looks like this:

```
<canvas id=c style=width:99%><img src=# onload=for(a=c.getContext`2d`,i=e='';a.drawImage(this,i--,0),t=a.getImageData(0,0,1,1).data[0];)e+=String.fromCharCode(t);eval(e)>
```

Both the canvas element `c` and the graphics context `a` will be available for the app, so we don't need to duplicate the initialization in the app. The code for the app - ie, the code we are going to turn into a PNG - can be simplified a bit, to this:

```
v=0;w=c.width;m=Math.cos;p=[-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1];f="012303740451654762156732".split``;r=[];setInterval('a.clearRect(0,0,w,w);for(i=0;24>i;i++)u=m(v+11),o=m(v),r[i]=p[i]*o-p[i+1]*u,r[i+1]=p[i]*u+p[i+1]*o,r[i+2]=p[i+2]*o-r[i]*u,r[i]=p[i+2]*u+r[i]*o,r[i]=99*r[i]/(5-r[++i+1])+w/2,r[i]=99*r[i]/(5-r[++i])+w/3;for(i=0;24>i;i++){a.beginPath();a.moveTo(r[3*f[i]],r[3*f[i]+1]);s=r[3*f[i]+2];for(j=3;j--;)s+=r[3*f[++i]+2],a.lineTo(r[3*f[i]],r[3*f[i]+1]);a.closePath();a.fillStyle="rgb(0,0,"+(127+32*s|0)+")";.6<s&&a.fill()}v+=.01',9)
```

If we run this through the generator script, the output is 555 bytes! However, we see some strange characters at the top of the screen. This happens because the image file, consisting of binary data, also has some bytes inside the ASCII range that contains normal letters. That means that the browser will print the letters on screen. One solution is to hide the text using CSS - we just add some JavaScript at the start of the app that makes the text color white:

```
body.style="color:#fff";v=0;w=c.width;m=Math.cos;(...)
```

The CSS we added to the decoder can also be moved over to the application - and then run through the Deflate algorithm.

```
c.style="width:99%";body.style="color:#fff";v=0;w=c.width;m=Math.cos;(...)
```

With these changes in place, the code is 564 bytes. Not bad!

It would be interesting to know more about the compression ratio. How well does the various parts of the source code compress? Which parts are more or less uncompressable? Should they be rewritten? Since the app itself is quite small the compressor does not have much data to work with. This means that if we insert extra code, the compressed output might still become smaller if the source code now contains more common substrings than before. Refactoring to optimize for compressability sounds fun, but complicated!

Fortunately, there is a tool that can help us do that. A program called `gzthermal` can produce a color plot where we see how much space each source code character takes. The scale indicates - from red (a little), via orange, yellow, green to blue (a lot) - how well each character is compressed. If we run `gzthermal` on our app, the output looks like this:

<p align="center">
<img src="images/gzthermal.png" width="90%">
</p>

Here we can see that text strings that are repeated are compressed well. In turn, this means that most API methods will be compressed poorly. Capital letters and unusual characters will also compress poorly. To make the smallest possible result, one must both reduce the source code itself and write it so it contains many common substrings. As an example, using variable names that also exist inside other strings seems to give good results.

If you want quick feedback on compression ratios you can also use Google's Closure compiler. It also provides useful output about compressability when processing source code.

<p align="center">
<img src="images/closure_compiler.png" width="90%">
</p>

And with that, we have reached the end of this article.

To sum up: We've created a small app, rewritten the code to be compact, and then created a self-extracting version of the app relying on image compression from the PNG format. The first version was 2156 bytes, and we cut this down to 564 bytes, i.e. to around 26% of the original size. At the same time, we managed to keep most of the functionality as it was.

Hope this has been interesting! Happy hacking!
